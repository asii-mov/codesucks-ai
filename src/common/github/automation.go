package github

import (
	"fmt"
	"strings"
	"time"

	"github.com/asii-mov/codesucks-ai/common"
	"github.com/google/go-github/v66/github"
)

// CreateFixBranch creates a new branch for security fixes
func (gc *GitHubClient) CreateFixBranch(owner, repo string) (*common.FixBranch, error) {
	// Get the default branch
	repoInfo, _, err := gc.Client.Repositories.Get(gc.Ctx, owner, repo)
	if err != nil {
		return nil, fmt.Errorf("failed to get repository info: %w", err)
	}

	defaultBranch := repoInfo.GetDefaultBranch()

	// Get the SHA of the default branch
	ref, _, err := gc.Client.Git.GetRef(gc.Ctx, owner, repo, "refs/heads/"+defaultBranch)
	if err != nil {
		return nil, fmt.Errorf("failed to get default branch ref: %w", err)
	}

	// Create a new branch name with timestamp
	timestamp := time.Now().Format("20060102-150405")
	branchName := fmt.Sprintf("security-fixes-%s", timestamp)

	// Create the new branch
	newRef := &github.Reference{
		Ref: github.String("refs/heads/" + branchName),
		Object: &github.GitObject{
			SHA: ref.Object.SHA,
		},
	}

	_, _, err = gc.Client.Git.CreateRef(gc.Ctx, owner, repo, newRef)
	if err != nil {
		return nil, fmt.Errorf("failed to create branch: %w", err)
	}

	return &common.FixBranch{
		BranchName: branchName,
		RepoOwner:  owner,
		RepoName:   repo,
		Fixes:      []common.SecurityFix{},
	}, nil
}

// ApplySecurityFix commits a security fix to the branch
func (gc *GitHubClient) ApplySecurityFix(branch *common.FixBranch, fix common.SecurityFix) error {
	// Get the current file content
	fileContent, _, _, err := gc.Client.Repositories.GetContents(
		gc.Ctx, branch.RepoOwner, branch.RepoName, fix.FilePath,
		&github.RepositoryContentGetOptions{Ref: branch.BranchName},
	)
	if err != nil {
		return fmt.Errorf("failed to get file content: %w", err)
	}

	// Decode the content
	content, err := fileContent.GetContent()
	if err != nil {
		return fmt.Errorf("failed to decode file content: %w", err)
	}

	// Apply the fix
	lines := strings.Split(content, "\n")
	if fix.StartLine < 1 || fix.EndLine > len(lines) {
		return fmt.Errorf("invalid line range: %d-%d for file with %d lines",
			fix.StartLine, fix.EndLine, len(lines))
	}

	// Replace the vulnerable code with the fixed code
	var newLines []string
	newLines = append(newLines, lines[:fix.StartLine-1]...)
	newLines = append(newLines, strings.Split(fix.FixedCode, "\n")...)
	newLines = append(newLines, lines[fix.EndLine:]...)

	newContent := strings.Join(newLines, "\n")

	// Commit the fix
	commitMessage := fmt.Sprintf("üîí Fix %s vulnerability in %s\n\n%s",
		fix.Vulnerability, fix.FilePath, fix.Description)

	_, _, err = gc.Client.Repositories.UpdateFile(
		gc.Ctx, branch.RepoOwner, branch.RepoName, fix.FilePath,
		&github.RepositoryContentFileOptions{
			Message: github.String(commitMessage),
			Content: []byte(newContent),
			SHA:     fileContent.SHA,
			Branch:  github.String(branch.BranchName),
		},
	)
	if err != nil {
		return fmt.Errorf("failed to commit fix: %w", err)
	}

	// Add fix to the branch record
	branch.Fixes = append(branch.Fixes, fix)

	return nil
}

// CreatePullRequest creates a PR for the security fixes
func (gc *GitHubClient) CreatePullRequest(branch *common.FixBranch) error {
	if len(branch.Fixes) == 0 {
		return fmt.Errorf("no fixes to create PR for")
	}

	// Generate PR title and body
	title := fmt.Sprintf("üîí Security fixes (%d vulnerabilities)", len(branch.Fixes))

	var bodyBuilder strings.Builder
	bodyBuilder.WriteString("## üîí Automated Security Fixes\n\n")
	bodyBuilder.WriteString("This PR contains automated security fixes generated by codesucks-ai.\n\n")
	bodyBuilder.WriteString("### Vulnerabilities Fixed:\n\n")

	for i, fix := range branch.Fixes {
		bodyBuilder.WriteString(fmt.Sprintf("%d. **%s** in `%s` (lines %d-%d)\n",
			i+1, fix.Vulnerability, fix.FilePath, fix.StartLine, fix.EndLine))
		bodyBuilder.WriteString(fmt.Sprintf("   - %s\n\n", fix.Description))
	}

	bodyBuilder.WriteString("### Review Instructions:\n")
	bodyBuilder.WriteString("- ‚úÖ Verify that the fixes address the security vulnerabilities\n")
	bodyBuilder.WriteString("- ‚úÖ Test the changes to ensure functionality is preserved\n")
	bodyBuilder.WriteString("- ‚úÖ Review the generated fixes for any potential side effects\n\n")
	bodyBuilder.WriteString("ü§ñ Generated by codesucks-ai with AI-powered security analysis")

	// Get default branch for base
	repoInfo, _, err := gc.Client.Repositories.Get(gc.Ctx, branch.RepoOwner, branch.RepoName)
	if err != nil {
		return fmt.Errorf("failed to get repository info: %w", err)
	}

	// Create the pull request
	pr, _, err := gc.Client.PullRequests.Create(gc.Ctx, branch.RepoOwner, branch.RepoName,
		&github.NewPullRequest{
			Title:               github.String(title),
			Head:                github.String(branch.BranchName),
			Base:                github.String(repoInfo.GetDefaultBranch()),
			Body:                github.String(bodyBuilder.String()),
			MaintainerCanModify: github.Bool(true),
		},
	)
	if err != nil {
		return fmt.Errorf("failed to create pull request: %w", err)
	}

	branch.PRNumber = pr.Number
	return nil
}

// CreateIssueForConversation creates a GitHub issue for user conversation about the fixes
func (gc *GitHubClient) CreateIssueForConversation(branch *common.FixBranch) error {
	if branch.PRNumber == nil {
		return fmt.Errorf("pull request must be created before conversation issue")
	}

	title := fmt.Sprintf("üí¨ Discussion: Security fixes in PR #%d", *branch.PRNumber)

	var bodyBuilder strings.Builder
	bodyBuilder.WriteString("## üí¨ Security Fixes Discussion\n\n")
	bodyBuilder.WriteString(fmt.Sprintf("This issue is for discussing the automated security fixes in PR #%d.\n\n", *branch.PRNumber))
	bodyBuilder.WriteString("### Questions? Concerns? Feedback?\n\n")
	bodyBuilder.WriteString("Feel free to comment here with:\n")
	bodyBuilder.WriteString("- ü§î Questions about the fixes\n")
	bodyBuilder.WriteString("- üö® Concerns about the changes\n")
	bodyBuilder.WriteString("- üí° Suggestions for improvements\n")
	bodyBuilder.WriteString("- üêõ Issues found during testing\n\n")
	bodyBuilder.WriteString("### Vulnerability Summary:\n\n")

	for i, fix := range branch.Fixes {
		bodyBuilder.WriteString(fmt.Sprintf("%d. **%s** in `%s`\n", i+1, fix.Vulnerability, fix.FilePath))
	}

	bodyBuilder.WriteString("\nü§ñ I'm here to help with any questions or adjustments needed!\n")
	bodyBuilder.WriteString("\n---\n*Powered by codesucks-ai with AI assistance*")

	// Create the issue
	issue, _, err := gc.Client.Issues.Create(gc.Ctx, branch.RepoOwner, branch.RepoName,
		&github.IssueRequest{
			Title:  github.String(title),
			Body:   github.String(bodyBuilder.String()),
			Labels: &[]string{"security", "automated-fix", "discussion"},
		},
	)
	if err != nil {
		return fmt.Errorf("failed to create conversation issue: %w", err)
	}

	branch.IssueNumber = issue.Number
	return nil
}

// MonitorIssueComments monitors the conversation issue for new comments
func (gc *GitHubClient) MonitorIssueComments(branch *common.FixBranch, callback func(comment string) string) error {
	if branch.IssueNumber == nil {
		return fmt.Errorf("no conversation issue found")
	}

	// Get the issue to check for new comments
	comments, _, err := gc.Client.Issues.ListComments(gc.Ctx, branch.RepoOwner, branch.RepoName,
		*branch.IssueNumber, &github.IssueListCommentsOptions{})
	if err != nil {
		return fmt.Errorf("failed to get issue comments: %w", err)
	}

	// For now, just process existing comments - in a real implementation,
	// this would track last seen comment and respond to new ones
	for _, comment := range comments {
		if comment.User != nil && comment.Body != nil {
			// Generate a response using the callback
			response := callback(*comment.Body)
			if response != "" {
				// Post the response
				_, _, err := gc.Client.Issues.CreateComment(gc.Ctx,
					branch.RepoOwner, branch.RepoName, *branch.IssueNumber,
					&github.IssueComment{Body: github.String(response)})
				if err != nil {
					return fmt.Errorf("failed to post response: %v", err)
				}
			}
		}
	}

	return nil
}

// ListRepositoryIssues lists open issues in a repository
func (gc *GitHubClient) ListRepositoryIssues(owner, repo string) ([]*github.Issue, error) {
	issues, _, err := gc.Client.Issues.ListByRepo(gc.Ctx, owner, repo, &github.IssueListByRepoOptions{
		State: "open",
		ListOptions: github.ListOptions{
			PerPage: 100,
		},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list repository issues: %w", err)
	}

	return issues, nil
}

// GetPullRequestByBranch finds a PR for a specific branch
func (gc *GitHubClient) GetPullRequestByBranch(owner, repo, branch string) (*github.PullRequest, error) {
	prs, _, err := gc.Client.PullRequests.List(gc.Ctx, owner, repo, &github.PullRequestListOptions{
		Head:  fmt.Sprintf("%s:%s", owner, branch),
		State: "open",
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list pull requests: %w", err)
	}

	if len(prs) == 0 {
		return nil, fmt.Errorf("no pull request found for branch %s", branch)
	}

	return prs[0], nil
}

// CheckBranchExists checks if a branch exists in the repository
func (gc *GitHubClient) CheckBranchExists(owner, repo, branch string) (bool, error) {
	_, _, err := gc.Client.Git.GetRef(gc.Ctx, owner, repo, "refs/heads/"+branch)
	if err != nil {
		if strings.Contains(err.Error(), "404") {
			return false, nil
		}
		return false, fmt.Errorf("failed to check branch existence: %w", err)
	}
	return true, nil
}

// DeleteBranch deletes a branch from the repository
func (gc *GitHubClient) DeleteBranch(owner, repo, branch string) error {
	_, err := gc.Client.Git.DeleteRef(gc.Ctx, owner, repo, "refs/heads/"+branch)
	if err != nil {
		return fmt.Errorf("failed to delete branch: %w", err)
	}
	return nil
}

// AddLabelsToPullRequest adds labels to a pull request
func (gc *GitHubClient) AddLabelsToPullRequest(owner, repo string, prNumber int, labels []string) error {
	_, _, err := gc.Client.Issues.AddLabelsToIssue(gc.Ctx, owner, repo, prNumber, labels)
	if err != nil {
		return fmt.Errorf("failed to add labels to PR: %w", err)
	}
	return nil
}

// RequestReview requests a review from specific users or teams
func (gc *GitHubClient) RequestReview(owner, repo string, prNumber int, reviewers []string, teamReviewers []string) error {
	reviewReq := &github.ReviewersRequest{
		Reviewers:     reviewers,
		TeamReviewers: teamReviewers,
	}

	_, _, err := gc.Client.PullRequests.RequestReviewers(gc.Ctx, owner, repo, prNumber, *reviewReq)
	if err != nil {
		return fmt.Errorf("failed to request review: %w", err)
	}
	return nil
}
